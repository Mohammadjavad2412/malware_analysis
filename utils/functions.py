from malware_analysis.settings import DAAS_MANAGER_URL
from analyze.models import UbaReport, Files, MimeTypes
from analyze.serializers import MimetypesSerializers
import subprocess as sp
import os
import requests
import json
import logging

def get_allowed_files(username, password):

    body = {
        "email": username,       
        "password": password
    }
    manager_get_token_url = f"http://{DAAS_MANAGER_URL}/users/login/"
    request = requests.post(url=manager_get_token_url, data=body)
    if request.status_code ==200:
        response = json.loads(request.content)
        access_token = response['access_token']
        request_headers = {"Authorization" : f"Bearer {access_token}"}
        manager_user_profile_url = f"http://{DAAS_MANAGER_URL}/users/profile/"
        request = requests.get(url=manager_user_profile_url, headers=request_headers)
        if request.status_code == 200:
            response = json.loads(request.content)
            allowed_download = response['allowed_files_type_for_download']
            allowed_upload = response['allowed_files_type_for_upload']
            return allowed_download, allowed_upload
        elif request.status_code == 400:
            raise CustomException("invalid data passed", 400)    
        else:
            raise CustomException("server down, try later", 500)
    elif request.status_code == 400:
        raise CustomException("invalid data passed", 400)
    else:
        raise CustomException("server down, try later", 500)


def file_type_detection(file_path, file_content_type, file_hash, transmission_type, username, file_name):
    COMMAND = ['file', '-i', f'{file_path}']
    proc = sp.Popen(COMMAND, stdin=sp.PIPE, stderr=sp.PIPE, stdout=sp.PIPE)
    out, err = proc.communicate()
    if out:
        pre_content = out.decode().split(':')
        content = pre_content[1].split(';')[0].strip()
    logging.info(file_content_type)
    if file_content_type == 'application/x-msdos-program' or file_content_type == "application/vnd.microsoft.portable-executable":
        file_content_type = 'application/x-dosexec'
    if file_content_type == 'application/x-iso9660':
        file_content_type = 'application/octet-stream'
    mimetypes = MimeTypes.objects.all()
    ser_data = MimetypesSerializers(mimetypes, many=True)
    extenstion_content_mapper_dict = ser_data.data
    if file_content_type == content:
        try:
            extensions = []
            if content == 'application/x-dosexec':
                extension = ['.exe', '.dll']
                return extension
            if content == 'application/octet-stream':
                extension = ['.iso']
                return extension
            else:
                for i in range(len(extenstion_content_mapper_dict)):
                    if extenstion_content_mapper_dict[i]['mimetype'] == content:
                        extension = extenstion_content_mapper_dict[i]['extension']
                        extensions.append(extension)
                return extensions
        except:
            file_obj = Files.objects.get(file_hash=file_hash, username=username)
            file_obj.antiviruses_scanner_status = "FAILED"
            file_obj.yara_scanner_status = "FALIED"
            file_obj.clamav_scanner_status = "FAILED"
            file_obj.scan_result = "TRY_AGAIN"
            file_obj.save()
            raise CustomException("file extension Not Supported Error", 400)
    else:
        extensions = []
        for i in range(len(extenstion_content_mapper_dict)):
            if extenstion_content_mapper_dict[i]['mimetype'] == content:
                extension = extenstion_content_mapper_dict[i]['extension']
                extensions.append(extension)
        name, extension = os.path.splitext(file_name)
        if extensions:
            extension_to_save = extensions[0]
            real_file_name_to_save = f"{name}{extension_to_save}"
        else:
            real_file_name_to_save = f"{name}.*"
        check_uba_obj = UbaReport.objects.filter(file_hash=file_hash, username=username)
        if not check_uba_obj:
            uba_obj = UbaReport(
                file_hash=file_hash,
                username=username,
                transmission_type=transmission_type,
                original_file_name=real_file_name_to_save,
                file_names=[f'{file_name}'],
                malbehave_count=1
            )
            uba_obj.save()
        Files.objects.filter(file_hash=file_hash, username=username, scan_result="TRY_AGAIN").delete()
        file_obj = Files.objects.get(file_hash=file_hash, username=username)
        file_obj.antiviruses_scanner_status = "FAILED"
        file_obj.yara_scanner_status = "FALIED"
        file_obj.clamav_scanner_status = "FAILED"
        file_obj.scan_result = "TRY_AGAIN"
        file_obj.save()
        raise CustomException("content of the file and it's name is different", 400)


def get_file_hash(file_path):
    Command = ['md5sum', f"{file_path}"]
    proc = sp.Popen(Command, stderr=sp.PIPE, stdout=sp.PIPE)
    stdout, stderr = proc.communicate()
    if stderr:
        file_hash_error = {"error",stderr.decode()}
    decoded_stdout = stdout.decode()
    file_hash = decoded_stdout.split()[0]
    return file_hash


def return_real_content(file_path):
    COMMAND = ['file', '-i', f'{file_path}']
    proc = sp.Popen(COMMAND, stdin=sp.PIPE, stderr=sp.PIPE, stdout=sp.PIPE)
    out, err = proc.communicate()
    if out:
        pre_content = out.decode().split(':')
        content = pre_content[1].split(';')[0].strip()
    return content

class CustomException(Exception):
    def __init__(self, message, status_code):
        super().__init__(message)
        self.status_code = status_code
