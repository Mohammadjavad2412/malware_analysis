from malware_analysis.settings import DAAS_MANAGER_URL
from analyze.models import UbaReport, Files, MimeTypes
from analyze.serializers import MimetypesSerializers
from django.utils.translation import gettext as _
from utils.logs import define_sys_logger
import subprocess as sp
import os
import requests
import json
import ast
import logging

def get_allowed_files(username, password):

    body = {
        "email": username,       
        "password": password
    }
    manager_get_token_url = f"http://{DAAS_MANAGER_URL}/users/login/"
    request = requests.post(url=manager_get_token_url, data=body)
    if request.status_code ==200:
        response = json.loads(request.content)
        access_token = response['access_token']
        request_headers = {"Authorization" : f"Bearer {access_token}"}
        manager_user_profile_url = f"http://{DAAS_MANAGER_URL}/users/profile/"
        request = requests.get(url=manager_user_profile_url, headers=request_headers)
        if request.status_code == 200:
            response = json.loads(request.content)
            allowed_download = response['allowed_files_type_for_download']
            allowed_upload = response['allowed_files_type_for_upload']
            return allowed_download, allowed_upload
        elif request.status_code == 400:
            raise CustomException(_("invalid data passed"), 400)    
        else:
            raise CustomException(_("server down, try later"), 500)
    elif request.status_code == 400:
        raise CustomException(_("invalid data passed"), 400)
    else:
        raise CustomException(_("server down, try later"), 500)



def file_type_detection(file_path, file_content_type, file_hash, transmission_type, username, file_name):
    logger = define_sys_logger()
    logger.info(f" File: {file_name} of username : {username} has been sent to dlp for further analysis")
    COMMAND = ['file', '-i', f'{file_path}']
    proc = sp.Popen(COMMAND, stdin=sp.PIPE, stderr=sp.PIPE, stdout=sp.PIPE)
    out, err = proc.communicate()
    if out:
        pre_content = out.decode().split(':')
        content = pre_content[1].split(';')[0].strip()
    if file_content_type == content:
        name, extension = os.path.splitext(file_name)
        return extension
    else:
        name, extension = os.path.splitext(file_name)
        ex = f"'{extension}',"
        mimetype_obj = MimeTypes.objects.filter(extension__contains=ex)
        if mimetype_obj:
            mimetype_obj = mimetype_obj[0]
            ser_mimetype_obj = MimetypesSerializers(instance= mimetype_obj)
            mimetypes = ser_mimetype_obj.data['mimetype_list']
            if file_content_type and content in mimetypes:
                return extension
            else:
                real_file_name_to_save = content
        else:
            real_file_name_to_save = content
        check_uba_obj = UbaReport.objects.filter(file_hash=file_hash, username=username)
        if not check_uba_obj:
            uba_obj = UbaReport(
                file_hash=file_hash,
                username=username,
                transmission_type=transmission_type,
                original_file_name=real_file_name_to_save,
                file_names=[f'{file_name}'],
                malbehave_count=1
            )
            uba_obj.save()
        Files.objects.filter(file_hash=file_hash, username=username, scan_result="TRY_AGAIN").delete()
        file_obj = Files.objects.get(file_hash=file_hash, username=username)
        file_obj.antiviruses_scanner_status = "FAILED"
        file_obj.yara_scanner_status = "FALIED"
        file_obj.clamav_scanner_status = "FAILED"
        file_obj.scan_result = "TRY_AGAIN"
        file_obj.save()
        raise CustomException("content of the file does not match it's extension, contact your administrator", 400)


def get_file_hash(file_path):
    Command = ['md5sum', f"{file_path}"]
    proc = sp.Popen(Command, stderr=sp.PIPE, stdout=sp.PIPE)
    stdout, stderr = proc.communicate()
    if stderr:
        file_hash_error = {"error",stderr.decode()}
    decoded_stdout = stdout.decode()
    file_hash = decoded_stdout.split()[0]
    return file_hash


def return_real_content(file_path):
    COMMAND = ['file', '-i', f'{file_path}']
    proc = sp.Popen(COMMAND, stdin=sp.PIPE, stderr=sp.PIPE, stdout=sp.PIPE)
    out, err = proc.communicate()
    if out:
        pre_content = out.decode().split(':')
        content = pre_content[1].split(';')[0].strip()
    return content



#this comment is for mr sharafkandi
def clamav_package_install():
    sp.run(['apt-get', '-y', 'update'])
    sp.run(['apt', 'install', '-y', 'clamav'])
    sp.run(['apt', 'install', '-y', 'clamav-daemon'])
    sp.run(['service', 'clamav-daemon', 'stop'])
    sp.run(['freshclam'])
    sp.run(['service', 'clamav-daemon', 'start'])

def add_custom_mimetypes():
    extension_list = ['.exe', '.rar']
    for extension in extension_list:
        if extension == '.exe':
            unix_content = 'application/x-dosexec'
            py_content = 'application/x-ms-dos-executable'
            extension_search_filter = f"'{extension}'"
            mimetype_obj = MimeTypes.objects.filter(extension__contains=extension_search_filter)
            if mimetype_obj:
                mimetype_obj = mimetype_obj[0]
                mimetype = mimetype_obj.mimetype
                mimetype = ast.literal_eval(mimetype)
                if unix_content not in mimetype:
                    unix_content = (unix_content,)
                    mimetype = mimetype + unix_content
                if py_content not in mimetype:
                    py_content = (py_content,)
                    mimetype = mimetype + py_content
                mimetype_obj.mimetype = mimetype
                mimetype_obj.save()
            else:
                mimetype_obj = MimeTypes(
                    mimetype = (unix_content, py_content),
                    extension = (extension,)
                )
                mimetype_obj.save()
        elif extension == '.rar':
            unix_content = 'application/x-rar'
            py_content = 'application/vnd.rar'
            extension_search_filter = f"'{extension}'"
            mimetype_obj = MimeTypes.objects.filter(extension__contains=extension_search_filter)
            if mimetype_obj:
                mimetype_obj = mimetype_obj[0]
                mimetype = mimetype_obj.mimetype
                mimetype = ast.literal_eval(mimetype)
                if unix_content not in mimetype:
                    unix_content = (unix_content,)
                    mimetype = mimetype + unix_content
                if py_content not in mimetype:
                    py_content = (py_content,)
                    mimetype = mimetype + py_content
                mimetype_obj.mimetype = mimetype
                mimetype_obj.save()
            else:
                mimetype_obj = MimeTypes(
                    mimetype = (unix_content, py_content),
                    extension = (extension,)
                )
                mimetype_obj.save()

class CustomException(Exception):
    def __init__(self, message, status_code):
        super().__init__(message)
        self.status_code = status_code
