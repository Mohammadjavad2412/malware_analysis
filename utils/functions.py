from malware_analysis.settings import DAAS_MANAGER_URL, SECURE_LINK_SECRET, SANDBOX_GATEWAY_URL, LICENSE_ID
from analyze.models import UbaReport, Files, MimeTypes, Scanners
from django.utils.translation import gettext as _
from utils.logs import define_sys_logger
from zipfile import ZipFile
from malware_analysis import settings
import random
import subprocess as sp
import os
import requests
import json
import ast
import base64
import hashlib
import calendar
import datetime
import logging
import traceback


def get_allowed_files(username, password):

    body = {
        "email": username,       
        "password": password
    }
    manager_get_token_url = f"https://{DAAS_MANAGER_URL}/users/login/"
    request = requests.post(url=manager_get_token_url, data=body)
    if request.status_code ==200:
        response = json.loads(request.content)
        access_token = response['access_token']
        request_headers = {"Authorization" : f"Bearer {access_token}"}
        manager_user_profile_url = f"https://{DAAS_MANAGER_URL}/users/profile/"
        request = requests.get(url=manager_user_profile_url, headers=request_headers)
        if request.status_code == 200:
            response = json.loads(request.content)
            allowed_download = response['allowed_files_type_for_download']
            allowed_upload = response['allowed_files_type_for_upload']
            return allowed_download, allowed_upload
        elif request.status_code == 400:
            raise CustomException(_("invalid data passed"), 400)    
        else:
            raise CustomException(_("server down, try later"), 500)
    elif request.status_code == 400:
        raise CustomException(_("invalid data passed"), 400)
    else:
        raise CustomException(_("server down, try later"), 500)



def file_type_detection(file_path, file_content_type, file_hash, transmission_type, username, file_name):
    from analyze.serializers import MimetypesSerializers
    logger = define_sys_logger()
    logger.info(f" File: {file_name} of username : {username} has been sent to dlp for further analysis")
    if file_content_type == "application/zip":
        print(settings.BASE_DIR)
        with ZipFile(file_path, 'r') as zip_ref:
            extensions = []
            file_paths = []
            tmp_path = os.path.join(f"{settings.BASE_DIR}", 'files')
            os.chdir(tmp_path)
            tmp_user_path = f"{username}_{file_name}_{random.randint(0, 10000)}"
            COMMAND = ['mkdir',tmp_user_path]
            proc = sp.Popen(COMMAND, stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE)
            proc.communicate()
            COMMAND = ['chmod','777',tmp_user_path]
            proc = sp.Popen(COMMAND, stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE)
            proc.communicate()
            zip_ref.extractall(tmp_user_path)
            print(tmp_user_path)
            for root, directories, files in os.walk(tmp_user_path):
                for filename in files:
                    file_path = os.path.join(root, filename)
                    file_paths.append(file_path)
            for extracted_file in file_paths:
                exc_file_name = extracted_file.split('/')[1]
                if exc_file_name.endswith('.rar') or exc_file_name.endswith('.zip'):
                    raise CustomException('zip file is not acceptable', 400)
                is_dir = os.path.isdir(extracted_file)
                if is_dir:
                    raise CustomException('zip file is not acceptable', 400)
                name, extension = os.path.splitext(extracted_file)
                proc = sp.Popen(['file', '-i', f'{extracted_file}'], stdin=sp.PIPE, stderr=sp.PIPE, stdout=sp.PIPE)
                out, err = proc.communicate()
                if out:
                    pre_content = out.decode().split(':')
                    content = pre_content[1].split(';')[0].strip()
                    ex = f"'{extension}'"
                    mimetype_obj = MimeTypes.objects.filter(extension__contains=ex)
                    if mimetype_obj:
                        mimetype_obj = mimetype_obj[0]
                        ser_mimetype_obj = MimetypesSerializers(instance=mimetype_obj)
                        mimetypes = ser_mimetype_obj.data['mimetype_list']
                        if content in mimetypes:
                            extensions.append(extension)
                        else:
                            Files.objects.filter(file_hash=file_hash, username=username, scan_result="TRY_AGAIN").delete()
                            file_obj = Files.objects.get(file_hash=file_hash, username=username)
                            file_obj.antiviruses_scanner_status = "FAILED"
                            file_obj.yara_scanner_status = "FALIED"
                            file_obj.clamav_scanner_status = "FAILED"
                            file_obj.scan_result = "TRY_AGAIN"
                            file_obj.save()
                            raise CustomException(f"content of the file {extracted_file} and its extension does not match or not supported, contact your administrator", 400)
                    else:
                        raise CustomException(f"content of the file {extracted_file} not supported, contact your administrator", 400)
            return extensions    


    COMMAND = ['file', '-i', f'{file_path}']
    proc = sp.Popen(COMMAND, stdin=sp.PIPE, stderr=sp.PIPE, stdout=sp.PIPE)
    out, err = proc.communicate()
    if out:
        pre_content = out.decode().split(':')
        content = pre_content[1].split(';')[0].strip()
    if file_content_type == content:
        name, extension = os.path.splitext(file_name)
        return extension
    else:
        name, extension = os.path.splitext(file_name)
        ex = f"'{extension}',"
        mimetype_obj = MimeTypes.objects.filter(extension__contains=ex)
        if mimetype_obj:
            mimetype_obj = mimetype_obj[0]
            ser_mimetype_obj = MimetypesSerializers(instance= mimetype_obj)
            mimetypes = ser_mimetype_obj.data['mimetype_list']
            if file_content_type and content in mimetypes:
                return extension
            else:
                real_file_name_to_save = content
        else:
            real_file_name_to_save = content
        check_uba_obj = UbaReport.objects.filter(file_hash=file_hash, username=username)
        if not check_uba_obj:
            uba_obj = UbaReport(
                file_hash=file_hash,
                username=username,
                transmission_type=transmission_type,
                original_file_name=real_file_name_to_save,
                file_names=[f'{file_name}'],
                malbehave_count=1
            )
            uba_obj.save()
        Files.objects.filter(file_hash=file_hash, username=username, scan_result="TRY_AGAIN").delete()
        file_obj = Files.objects.get(file_hash=file_hash, username=username)
        file_obj.antiviruses_scanner_status = "FAILED"
        file_obj.yara_scanner_status = "FALIED"
        file_obj.clamav_scanner_status = "FAILED"
        file_obj.scan_result = "TRY_AGAIN"
        file_obj.save()
        raise CustomException("content of the file does not match it's extension, contact your administrator", 400)


def get_file_hash(file_path):
    Command = ['md5sum', f"{file_path}"]
    proc = sp.Popen(Command, stderr=sp.PIPE, stdout=sp.PIPE)
    stdout, stderr = proc.communicate()
    if stderr:
        file_hash_error = {"error",stderr.decode()}
    decoded_stdout = stdout.decode()
    file_hash = decoded_stdout.split()[0]
    return file_hash


def return_real_content(file_path):
    COMMAND = ['file', '-i', f'{file_path}']
    proc = sp.Popen(COMMAND, stdin=sp.PIPE, stderr=sp.PIPE, stdout=sp.PIPE)
    out, err = proc.communicate()
    if out:
        pre_content = out.decode().split(':')
        content = pre_content[1].split(';')[0].strip()
    return content



#this comment is for mr sharafkandi
def clamav_package_install():
    sp.run(['apt-get', '-y', 'update'])
    sp.run(['apt', 'install', '-y', 'clamav'])
    sp.run(['apt', 'install', '-y', 'clamav-daemon'])
    sp.run(['service', 'clamav-daemon', 'stop'])
    sp.run(['freshclam'])
    sp.run(['service', 'clamav-daemon', 'start'])

def add_custom_mimetypes():
    extension_to_mimetype = {
        '.exe': ('application/x-dosexec', 'application/x-ms-dos-executable'),
        '.rar': ('application/x-rar', 'application/vnd.rar'),
        '.mp4': ('video/mp4', 'application/octet-stream'),
        '.yml': ('text/plain', 'text/yaml')
    }
    for extension, mime_types in extension_to_mimetype.items():
        unix_content, py_content = mime_types
        extension_search_filter = f"'{extension}'"
        mimetype_obj = MimeTypes.objects.filter(extension__contains=extension_search_filter)
        if mimetype_obj:
            mimetype_obj = mimetype_obj[0]
            mimetype = mimetype_obj.mimetype
            mimetype = ast.literal_eval(mimetype)
            if unix_content not in mimetype:
                unix_content = (unix_content,)
                mimetype = mimetype + unix_content
            if py_content not in mimetype:
                py_content = (py_content,)
                mimetype = mimetype + py_content
            mimetype_obj.mimetype = mimetype
            mimetype_obj.save()
        else:
            mimetype_obj = MimeTypes(
                mimetype = (unix_content, py_content),
                extension = (extension,)
            )
            mimetype_obj.save()


def generate_secure_link(uri):
    try:
        secret = SECURE_LINK_SECRET
        future = datetime.datetime.utcnow() + datetime.timedelta(minutes=5)
        expiry = calendar.timegm(future.timetuple())
        secure_link = f"{secret}{uri}{expiry}".encode('utf-8')
        hash = hashlib.md5(secure_link).digest()
        encoded_hash = base64.urlsafe_b64encode(hash)
        str_hash = encoded_hash.decode('utf-8').rstrip('=')
        return str_hash ,expiry
    except:
        logging.error(traceback.format_exc())
        
def vt_scan_endpoint(file_hash):
    license_id = LICENSE_ID
    uri = "/malvt_gateway/malvt"
    url = f'https://{SANDBOX_GATEWAY_URL}{uri}?file_hash={file_hash}&license_id={license_id}'
    return uri, url

def license_profile_endpoint():
    license_id = LICENSE_ID
    uri = "/users/license_profile/"
    url = f'https://{SANDBOX_GATEWAY_URL}{uri}?license_id={license_id}'
    return uri, url 
    
def get_scanner_configuration():
    scanner_conf = Scanners.objects.first()
    if scanner_conf is None:
        return {
            'sandbox_is_active' : False,
            'clamav_is_active' : False,
            'yara_is_active' : False
        }
    else:
        return {
            'sandbox_is_active' : scanner_conf.sandbox_is_active,
            'clamav_is_active' : scanner_conf.clamav_is_active,
            'yara_is_active' : scanner_conf.yara_is_active
        }

class CustomException(Exception):
    def __init__(self, message, status_code):
        super().__init__(message)
        self.status_code = status_code
