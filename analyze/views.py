from rest_framework.viewsets import ModelViewSet
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from analyze.models import Files, UbaReport
from analyze.serializers import FileSerializers, MaliciousUbaSerializers
from django_filters.rest_framework import DjangoFilterBackend
from django.utils.encoding import smart_str
from malware_analysis import settings
from analyze.tasks import scan_files_task
from analyze.throttles import ConditionalThrottle
from analyze.authenticate import CustomBasicAuthentication
from analyze.permissions import IsOnlyOwner
from malware_analysis.pagination import CustomPagination
from rest_framework import filters
from django.utils import timezone
from datetime import timedelta
from datetime import date as dt
from utils.functions import get_allowed_files, file_type_detection, get_file_hash, return_real_content ,CustomException
import requests
import json
import base64
import logging
import os
import traceback

class ScanFiles(ModelViewSet):

    queryset = Files.objects.all().order_by('-created_at')
    serializer_class = FileSerializers
    filter_backends = [DjangoFilterBackend, filters.SearchFilter]
    filterset_fields = ['created_at','transmission_type', 'username']
    search_fields = ['username',  'file_name']
    throttle_classes = [ConditionalThrottle]
    authentication_classes = [CustomBasicAuthentication]
    permission_classes = [IsOnlyOwner]
    pagination_class = CustomPagination


    def list(self, request, *args, **kwargs):
        if request.query_params.get('file_hash'):
            auth_header = self.request.headers.get('Authorization')
            auth_type, auth_string = auth_header.split(' ')
            decoded_auth_string = base64.b64decode(smart_str(auth_string)).decode('utf-8')
            username, password= decoded_auth_string.split(':')
            file_hash = request.query_params.get('file_hash')
            file_name = request.query_params.get('file_name')
            file_obj_exists = Files.objects.filter(file_hash=file_hash, username=username).exists()
            if file_obj_exists:
                file_obj = Files.objects.filter(file_hash=file_hash, username=username).last()
                file_obj_name = file_obj.file_name
                file_obj_username = file_obj.username
                file_transmission_type = file_obj.transmission_type
                if file_name != file_obj_name:
                    try:
                        uba_obj = UbaReport.objects.get(file_hash=file_hash,username=file_obj_username)
                        old_count =uba_obj.malbehave_count 
                        new_count = old_count + 1
                        uba_obj.malbehave_count = new_count
                        uba_obj_file_names = uba_obj.file_names
                        uba_obj_file_names.append(file_name)
                        uba_obj.file_names = uba_obj_file_names
                        if new_count > int(settings.ALLOWED_MALBEHAVE_COUNT):
                            uba_obj.is_ban = True
                            uba_obj.save()
                            body_login_request = {
                                "email": username,
                                "password": password
                            }
                            server_request = requests.post(url=f"http://{settings.DAAS_MANAGER_URL}/users/login/", data=body_login_request)
                            if server_request.status_code ==200:
                                response = json.loads(server_request.content)
                                access_token = response['access_token']
                                headers = {"Authorization" : f"Bearer {access_token}"}
                                server_request = requests.get(url=f"http://{settings.DAAS_MANAGER_URL}/users/lock_my_account/", headers=headers)
                                if server_request.status_code == 200:
                                    return Response({"error": "user daas acoount has been block due to many file change attempts"}, status.HTTP_400_BAD_REQUEST)
                                else:
                                    return Response({'error': 'server down, please try again later...'}, status.HTTP_500_INTERNAL_SERVER_ERROR)
                            else:
                                return Response({'error': 'server down, please try again later...'}, status.HTTP_500_INTERNAL_SERVER_ERROR)
                        else:
                            uba_obj.save()
                            org_file = Files.objects.filter(file_hash=file_hash,file_name=file_obj_name).last()
                            ser_data = FileSerializers(instance=org_file)
                            return Response(ser_data.data,status=status.HTTP_200_OK)
                    except:
                        uba_obj = UbaReport(
                            username = file_obj_username,
                            file_hash = file_hash,
                            file_names = [f'{file_name}'],
                            transmission_type = file_transmission_type,
                            malbehave_count = 1,
                            original_file_name = file_obj_name
                        )
                        uba_obj.save()
                        org_file = Files.objects.filter(file_hash=file_hash,file_name=file_obj_name).last()
                        ser_data = FileSerializers(instance=org_file)
                        return Response(ser_data.data,status=status.HTTP_200_OK)
                else:
                    ser_data = FileSerializers(instance=file_obj)
                    return Response(ser_data.data, status=status.HTTP_200_OK)
            else:
                file_obj = Files.objects.filter(file_hash=file_hash, username=username)
                ser_data = FileSerializers(instance=file_obj, many=True)
                response = {}
                response['results'] = ser_data.data
                return Response(response, status.HTTP_200_OK)
        else:
            return super().list(request=request,*args,**kwargs)


    def create(self, request, *args, **kwargs):
        try:
            auth_header = self.request.headers.get('Authorization')
            _, auth_string = auth_header.split(' ')
            decoded_auth_string = base64.b64decode(smart_str(auth_string)).decode('utf-8')
            username, password= decoded_auth_string.split(':')
            data = request.data
            transmission_type = data.get('transmission_type')
            file = request.FILES.get('file')
            if file:
                file_name = file.name
                file_size = file.size
                file_content_type = file.content_type
                request_data = {
                    "file": file
                }
                serializer = self.get_serializer(data=request_data)
                if serializer.is_valid():
                    obj = Files(
                        file = file,
                        username = username,
                        file_name = file_name,
                        file_size_in_bytes = file_size,
                        transmission_type = transmission_type,
                        yara_scanner_status = "IN_PROCESS",
                        clamav_scanner_status = "IN_PROCESS",
                        antiviruses_scanner_status = "IN_PROCESS"
                    )
                    obj.save()
                    obj_pk = obj.pk
                    get_file = obj.file.name
                    file_path = os.path.join(settings.BASE_DIR, f"{get_file}")
                    try:
                        file_hash= get_file_hash(file_path)
                        content = return_real_content(file_path)
                        obj.file_hash = file_hash
                        obj.file_content_type = content
                        obj.save()
                        allowed_download, allowed_upload = get_allowed_files(username, password)
                        file_type = file_type_detection(file_path, file_content_type, file_hash, transmission_type, username, file_name)
                    except CustomException as e:
                        if e.status_code ==500:
                            return Response({"error": str(e)}, status.HTTP_500_INTERNAL_SERVER_ERROR)
                        elif e.status_code==400:
                            return Response({"error": str(e)}, status.HTTP_400_BAD_REQUEST)
                    if transmission_type == 'download':
                        if isinstance(file_type, list):
                            existed = any(ext in file_type for ext in allowed_download)
                            if existed:
                                logging.info('file ok for download')
                                pass
                            else:
                                return Response({"error": "you are not permitted to download this type of file"}, status.HTTP_400_BAD_REQUEST)
                        else:
                            if file_type in allowed_download:
                                logging.info('file ok for download')
                                pass
                            else:
                                return Response({"error": "you are not permitted to download this type of file"}, status.HTTP_400_BAD_REQUEST)
                    elif transmission_type == 'upload':
                        if isinstance(file_type, list):    
                            existed = any(ext in file_type for ext in allowed_upload)
                            if existed:
                                logging.info('file ok for download')
                                pass
                            else:
                                return Response({"error": "you are not permitted to download this type of file"}, status.HTTP_400_BAD_REQUEST)
                        else:
                            if file_type in allowed_upload:
                                logging.info('file ok for upload')
                            else:
                                return Response({"error": "you are not permitted to upload this type of file"}, status.HTTP_400_BAD_REQUEST)
                    scan_files_task.delay(obj_pk, file_path)
                    return Response({"info":"scanning files in process"}, status.HTTP_200_OK)
                else:
                    return Response(serializer.errors, status.HTTP_400_BAD_REQUEST)
            else:
                return Response({"error": "file not sent properly"}, status.HTTP_400_BAD_REQUEST)
        except:
            logging.error(traceback.format_exc())
            return Response({"error":"something's wrong"}, status.HTTP_500_INTERNAL_SERVER_ERROR)


class MaliciousUba(ModelViewSet):

    queryset = UbaReport.objects.all().order_by('-updated_at')
    serializer_class = MaliciousUbaSerializers
    filter_backends = [DjangoFilterBackend, filters.SearchFilter]
    permission_classes = [IsOnlyOwner]
    authentication_classes = [CustomBasicAuthentication]
    pagination_class = CustomPagination
    filterset_fields = ['is_ban', 'created_at']
    search_fields = ['username',  'file_names']
    http_method_names = ['get', 'delete','patch']


class ScanStatsView(APIView):
    authentication_classes = [CustomBasicAuthentication]

    def get(self, request):
        try:
            current_time = timezone.now()
            current_year = current_time.year
            current_month = current_time.month
            current_day = current_time.day
            date = f"{current_year}-{current_month}-{current_day}"
            files = Files.objects.filter(created_at__date=date, yara_scanner_status="FINISHED", clamav_scanner_status="FINISHED", antiviruses_scanner_status="FINISHED")
            ser_data = FileSerializers(files, many=True) 
            today_scans_count = len(ser_data.data)
            first_scan_obj = Files.objects.all().first()
            first_scan_obj_date = first_scan_obj.created_at
            liscence_expire_date = first_scan_obj_date + timedelta(days=365)
            exp_year = liscence_expire_date.year
            exp_month = liscence_expire_date.month
            exp_day = liscence_expire_date.day
            current_time = timezone.now()
            current_year = current_time.year
            current_month = current_time.month
            current_day = current_time.day
            date_exp_obj = dt(exp_year,exp_month,exp_day)
            date_current_obj = dt(current_year, current_month, current_day)
            remaining_days = (date_exp_obj-date_current_obj).days
            response = {}
            response['today_scans'] = today_scans_count
            response['remaining_days'] = remaining_days
            return Response({"info": response}, status=status.HTTP_200_OK)
        except:
            return Response({"error", "server down, please try later..."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)




