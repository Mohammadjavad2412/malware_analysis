from rest_framework.viewsets import ModelViewSet
from rest_framework.views import APIView
from rest_framework.response import Response
from django.http import FileResponse
from django.db.models import Q
from rest_framework import status
from analyze.models import Files, UbaReport, MimeTypes, LogServerConfig, Scanners
from analyze.serializers import FileSerializers, MaliciousUbaSerializers, MimetypesSerializers, LogServerSerializer, ScannerSerializer
from malware_analysis.settings import LICENSE_ID
from django_filters.rest_framework import DjangoFilterBackend
from django.utils.encoding import smart_str
from malware_analysis import settings
from analyze.tasks import scan_files_task
from analyze.throttles import ConditionalThrottle
from analyze.authenticate import CustomBasicAuthentication
from analyze.permissions import IsOnlyOwner, IsOnlyAdmin
from malware_analysis.pagination import CustomPagination
from rest_framework import filters
from analyze.searching import CustomSearchFilter
from django.utils import timezone
from datetime import timedelta
from datetime import date as dt
from django.utils.translation import gettext as _
from utils.functions import get_allowed_files, file_type_detection, get_file_hash, return_real_content,CustomException 
from utils.logs import define_sys_logger
from utils.functions import license_profile_endpoint, generate_secure_link, get_scanner_configuration
import ast
import requests
import json
import base64
import logging
import os
import traceback

class ScanFiles(ModelViewSet):

    queryset = Files.objects.all().order_by('-created_at')
    serializer_class = FileSerializers
    filter_backends = [DjangoFilterBackend, filters.SearchFilter]
    filterset_fields = ['created_at','transmission_type', 'username']
    search_fields = ['username',  'file_name']
    throttle_classes = [ConditionalThrottle]
    authentication_classes = [CustomBasicAuthentication]
    permission_classes = [IsOnlyOwner]
    pagination_class = CustomPagination


    def list(self, request, *args, **kwargs):
        if request.query_params.get('file_hash'):
            auth_header = self.request.headers.get('Authorization')
            auth_type, auth_string = auth_header.split(' ')
            decoded_auth_string = base64.b64decode(smart_str(auth_string)).decode('utf-8')
            username, password= decoded_auth_string.split(':')
            file_hash = request.query_params.get('file_hash')
            file_name = request.query_params.get('file_name')
            # file_mime_type = request.query_params.get('file_mime_type')
            file_obj_exists = Files.objects.filter(file_hash=file_hash, username=username).exists()
            if file_obj_exists:
                file_obj = Files.objects.filter(file_hash=file_hash, username=username).last()
                file_obj_name = file_obj.file_name
                file_obj_username = file_obj.username
                file_transmission_type = file_obj.transmission_type
                file_mime_type = file_obj.received_file_content_type
                real_content = return_real_content(file_obj.file.path)
                if file_mime_type != real_content:
                    unused_char, file_extension = os.path.splitext(file_obj_name)
                    ex = f"'{file_extension}',"
                    file_type = MimeTypes.objects.filter(extension__contains=ex)
                    if file_type:
                        file_type = file_type[0] 
                        ser_file_type =MimetypesSerializers(instance=file_type)
                        mimetype_list = ser_file_type.data['mimetype_list']
                        if real_content and file_mime_type in mimetype_list:
                            if file_obj.scan_result == "TRY_AGAIN":
                                file_obj_pk = file_obj.pk
                                file_path = os.path.join(settings.BASE_DIR, f"{file_obj.file.name}")
                                result = scan_files_task.delay(file_obj_pk, file_path)
                                response = {}
                                response['scan_result'] = "TRY_AGAIN"
                                return Response(response, status.HTTP_200_OK)
                            else:
                                ser_data = FileSerializers(instance=file_obj)
                                return Response(ser_data.data, status=status.HTTP_200_OK)
                        else:
                            pass
                    else:
                        return Response({"error": _("could not find mime type with this extension in filetypes database,please add this type of file, then try again")}, status.HTTP_400_BAD_REQUEST)
                    try:
                        uba_obj = UbaReport.objects.get(file_hash=file_hash,username=file_obj_username)
                        old_count =uba_obj.malbehave_count 
                        new_count = old_count + 1
                        uba_obj.malbehave_count = new_count
                        uba_obj_file_names = uba_obj.file_names
                        uba_obj_file_names.append(file_name)
                        uba_obj.file_names = uba_obj_file_names
                        if new_count > int(settings.ALLOWED_MALBEHAVE_COUNT):
                            uba_obj.is_ban = True
                            uba_obj.save()
                            body_login_request = {
                                "email": username,
                                "password": password
                            }
                            server_request = requests.post(url=f"https://{settings.DAAS_MANAGER_URL}/users/login/", data=body_login_request)
                            if server_request.status_code ==200:
                                response = json.loads(server_request.content)
                                access_token = response['access_token']
                                headers = {"Authorization" : f"Bearer {access_token}"}
                                server_request = requests.get(url=f"https://{settings.DAAS_MANAGER_URL}/users/lock_my_account/", headers=headers)
                                if server_request.status_code == 200:
                                    return Response({"error": _("user daas acoount has been block due to many file change attempts")}, status.HTTP_400_BAD_REQUEST)
                                else:
                                    return Response({'error': _('server down, please try again later...')}, status.HTTP_500_INTERNAL_SERVER_ERROR)
                            else:
                                return Response({'error': _('server down, please try again later...')}, status.HTTP_500_INTERNAL_SERVER_ERROR)
                        else:
                            uba_obj.save()
                            org_file = Files.objects.filter(file_hash=file_hash,file_name=file_obj_name).last()
                            ser_data = FileSerializers(instance=org_file)
                            return Response(ser_data.data,status=status.HTTP_200_OK)
                    except:
                        uba_obj = UbaReport(
                            username = file_obj_username,
                            file_hash = file_hash,
                            file_names = [f'{file_name}'],
                            transmission_type = file_transmission_type,
                            malbehave_count = 1,
                            original_file_name = file_obj_name
                        )
                        uba_obj.save()
                        org_file = Files.objects.filter(file_hash=file_hash,file_name=file_obj_name).last()
                        ser_data = FileSerializers(instance=org_file)
                        return Response(ser_data.data,status=status.HTTP_200_OK)
                else:
                    sandbox_status = file_obj.antiviruses_scanner_status
                    clamav_status = file_obj.antiviruses_scanner_status
                    sandbox_status_code = file_obj.antiviruses_status_code
                    scan_result = file_obj.scan_result
                    if sandbox_status == "FAILED" and clamav_status == "FAILED" and scan_result != "TRY_AGAIN" or sandbox_status =="FINISHED" and sandbox_status_code!=200 and clamav_status=="FAILED":   
                        file_obj_pk = file_obj.pk
                        file_path = os.path.join(settings.BASE_DIR, f"{file_obj.file.name}")
                        result = scan_files_task.delay(file_obj_pk, file_path)
                        return Response({"info":_("scanning files in process")}, status.HTTP_200_OK)
                    else:
                        ser_data = FileSerializers(instance=file_obj)
                        return Response(ser_data.data, status=status.HTTP_200_OK)
            else:
                file_obj = Files.objects.filter(file_hash=file_hash, username=username)
                ser_data = FileSerializers(instance=file_obj, many=True)
                response = {}
                response['results'] = ser_data.data
                return Response(response, status.HTTP_200_OK)
        else:
            return super().list(request=request,*args,**kwargs)


    def create(self, request, *args, **kwargs):
        try:
            logger = define_sys_logger()
            auth_header = self.request.headers.get('Authorization')
            no_use, auth_string = auth_header.split(' ')
            decoded_auth_string = base64.b64decode(smart_str(auth_string)).decode('utf-8')
            username, password= decoded_auth_string.split(':')
            data = request.data
            transmission_type = data.get('transmission_type')
            file = request.FILES.get('file')
            if file:
                file_name = file.name
                file_size = file.size
                file_content_type = file.content_type
                request_data = {
                    "file": file
                }
                serializer = self.get_serializer(data=request_data)
                if serializer.is_valid():
                    if not Scanners.objects.exists():
                        return Response({"error": "scanners config required"})
                    scanner_conf = get_scanner_configuration()
                    obj = Files(
                        file = file,
                        username = username,
                        file_name = file_name,
                        file_size_in_bytes = file_size,
                        transmission_type = transmission_type,
                        received_file_content_type = file_content_type,
                        yara_scanner_status = "IN_PROCESS" if scanner_conf['yara_is_active'] else "IN_ACTIVE",
                        clamav_scanner_status = "IN_PROCESS" if scanner_conf['clamav_is_active'] else "IN_ACTIVE",
                        antiviruses_scanner_status = "IN_PROCESS" if scanner_conf['sandbox_is_active'] else "IN_ACTIVE"
                    )
                    obj.save()
                    obj_pk = obj.pk
                    get_file = obj.file.name
                    file_path = os.path.join(settings.BASE_DIR, f"{get_file}")
                    try:
                        file_hash= get_file_hash(file_path)
                        content = return_real_content(file_path)
                        obj.file_hash = file_hash
                        obj.file_content_type = content
                        obj.save()
                        allowed_download, allowed_upload = get_allowed_files(username, password)
                        file_type = file_type_detection(file_path, file_content_type, file_hash, transmission_type, username, file_name)
                    except CustomException as e:
                        if e.status_code ==500:
                            logger.error(f"scanning file : {file_name} for user : {username}  & ip address : {request.META['REMOTE_ADDR']} returned error with status code 500 probably because not validating in dlp module")
                            return Response({"error": str(e)}, status.HTTP_500_INTERNAL_SERVER_ERROR)
                        elif e.status_code==400:
                            logger.error(f"scanning file : {file_name} for user : {username}  & ip address : {request.META['REMOTE_ADDR']} returned error with status code 400 probably because not validating in dlp module")
                            return Response({"error": str(e)}, status.HTTP_400_BAD_REQUEST)
                    if transmission_type == 'download':
                        if isinstance(file_type, list):
                            existed = any(ext in file_type for ext in allowed_download)
                            if existed:
                                logging.info('file ok for download')
                                pass
                            else:
                                logger.error(f"request of User : {username} with requested file : {file_name} & ip address {request.META['REMOTE_ADDR']} returned error because {username} can not download this file extension")
                                return Response({"error": _("you are not permitted to download this type of file")}, status.HTTP_400_BAD_REQUEST)
                        else:
                            if file_type in allowed_download:
                                logging.info('file ok for download')
                                pass
                            else:
                                logger.error(f"request of User : {username} with requested file : {file_name} & ip address {request.META['REMOTE_ADDR']} returned error because {username} can not download this file extension")
                                return Response({"error": _("you are not permitted to download this type of file")}, status.HTTP_400_BAD_REQUEST)
                    elif transmission_type == 'upload':
                        if isinstance(file_type, list):    
                            existed = any(ext in file_type for ext in allowed_upload)
                            if existed:
                                logging.info('file ok for upload')
                                pass
                            else:
                                logger.error(f"request of User : {username} with requested file : {file_name} & ip address {request.META['REMOTE_ADDR']} returned error because {username} can not upload this file extension")
                                return Response({"error": _("you are not permitted to upload this type of file")}, status.HTTP_400_BAD_REQUEST)
                        else:
                            if file_type in allowed_upload:
                                logging.info('file ok for upload')
                            else:
                                logger.error(f"request of User : {username} with requested file : {file_name} & ip address {request.META['REMOTE_ADDR']} returned error because {username} can not upload this file extension")
                                return Response({"error": _("you are not permitted to upload this type of file")}, status.HTTP_400_BAD_REQUEST)
                    result = scan_files_task.delay(obj_pk, file_path)
                    logger.info(f"User with username : {username} & ip address : {request.META['REMOTE_ADDR']} {transmission_type}ed {file_name} for scan")
                    return Response({"info":_("scanning files in process")}, status.HTTP_200_OK)
                else:
                    logger.error(f"Scaninng file : {file_name} of user : {username} & ip address : {request.META['REMOTE_ADDR']} returned with status code 400 because of serialization error")
                    return Response(serializer.errors, status.HTTP_400_BAD_REQUEST)
            else:
                logger.error(f"Scanning file failed because file has not been sent to the file server properly by user : {username} & ip address : {request.META['REMOTE_ADDR']}")
                return Response({"error": _("file not sent properly")}, status.HTTP_400_BAD_REQUEST)
        except:
            logging.error(traceback.format_exc())
            logger.error(f"Request by user : {username} & ip address : {request.META['REMOTE_ADDR']} failed with status code 500")
            return Response({"error":_("something's wrong")}, status.HTTP_500_INTERNAL_SERVER_ERROR)


class MaliciousUba(ModelViewSet):

    queryset = UbaReport.objects.all().order_by('-updated_at')
    serializer_class = MaliciousUbaSerializers
    filter_backends = [DjangoFilterBackend, filters.SearchFilter]
    permission_classes = [IsOnlyOwner]
    authentication_classes = [CustomBasicAuthentication]
    pagination_class = CustomPagination
    filterset_fields = ['is_ban', 'created_at']
    search_fields = ['username',  'file_names']
    http_method_names = ['get', 'delete','patch']


class ScanStatsView(APIView):
    authentication_classes = [CustomBasicAuthentication]

    def get(self, request):
        try:
            current_time = timezone.now()
            current_year = current_time.year
            current_month = current_time.month
            current_day = current_time.day
            date = f"{current_year}-{current_month}-{current_day}"
            yara_finished = Q(yara_scanner_status="FINISHED")
            clamav_finished = Q(clamav_scanner_status="FINISHED")
            antiviruses_finished = Q(antiviruses_scanner_status="FINISHED")
            today_files = Files.objects.filter(created_at__date=date)
            files = today_files.filter(yara_finished | clamav_finished | antiviruses_finished)
            ser_data = FileSerializers(files, many=True) 
            today_scans_count = len(ser_data.data)
            first_scan_obj = Files.objects.all().first()
            first_scan_obj_date = first_scan_obj.created_at
            liscence_expire_date = first_scan_obj_date + timedelta(days=365)
            exp_year = liscence_expire_date.year
            exp_month = liscence_expire_date.month
            exp_day = liscence_expire_date.day
            current_time = timezone.now()
            current_year = current_time.year
            current_month = current_time.month
            current_day = current_time.day
            date_exp_obj = dt(exp_year,exp_month,exp_day)
            date_current_obj = dt(current_year, current_month, current_day)
            remaining_days = (date_exp_obj-date_current_obj).days
            malware_files = Files.objects.filter(scan_result="MALWARE")
            ser_malware_files = FileSerializers(malware_files, many=True)
            malware_files_count = len(ser_malware_files.data)
            response = {}
            response['today_scans'] = today_scans_count
            response['remaining_days'] = remaining_days
            response['malware_files'] = malware_files_count
            return Response({"info": response}, status=status.HTTP_200_OK)
        except:
            return Response({"error", _("server down, please try later...")}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class FileTypesView(ModelViewSet):
    queryset = MimeTypes.objects.all().order_by('-created_at')
    serializer_class = MimetypesSerializers
    filter_backends = [DjangoFilterBackend, filters.SearchFilter]
    permission_classes = [IsOnlyOwner]
    authentication_classes = [CustomBasicAuthentication]
    pagination_class = CustomPagination
    filterset_fields = ['mimetype', 'extension']
    search_fields = ['extension']

    def get_custom_search_fields(self):
        return ['mimetype']

    def create(self, request, *args, **kwargs):
        try:
            logger = define_sys_logger()
            file = request.FILES.get('file')
            name, extension = os.path.splitext(file.name)
            file_content = file.content_type
            ex = f"'{extension}',"
            mimetype_obj = MimeTypes.objects.filter(extension__contains=ex)
            if mimetype_obj:
                mimetype_obj = mimetype_obj[0]
                mimetype_obj.file = file
                mimetype_obj.save()
                file_path = os.path.join(settings.BASE_DIR, f"{mimetype_obj.file.name}")
                real_content = return_real_content(file_path)
                file_content = file.content_type
                mimetype = mimetype_obj.mimetype
                mimetype = ast.literal_eval(mimetype)
                if real_content not in mimetype:
                    real_content = (real_content,)
                    mimetype = mimetype + real_content
                if file_content not in mimetype:
                    file_content = (file_content,)
                    mimetype = mimetype + file_content
                mimetype_obj.mimetype = mimetype
                mimetype_obj.save()
            else:
                mimetype_obj = MimeTypes(
                    file = file
                )
                mimetype_obj.save()
                file_path = os.path.join(settings.BASE_DIR, f"{mimetype_obj.file.name}")
                real_content = return_real_content(file_path)
                file_content = file.content_type
                if file_content == real_content:
                    mimetype_obj.mimetype = (real_content,)
                    name, extension = os.path.splitext(mimetype_obj.file.name)
                    mimetype_obj.extension = (extension,)
                    mimetype_obj.save()    
                else:
                    mimetype_obj.mimetype = (real_content, file_content)
                    name, extension = os.path.splitext(mimetype_obj.file.name)
                    mimetype_obj.extension = (extension,)
                    mimetype_obj.save()
            logging.info(f"Admin added new mimetype and extension, response with status code 200")
            return Response({"info": _("new mimetype, extension added to database successfully")}, status=status.HTTP_200_OK)
        except:
            logger.error("f request for adding a new mimetype and extension resulted with error, status code 500")
            logging.error(traceback.format_exc())
            return Response({"error": _("something's wrong, try later")}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class FileDownload(ModelViewSet):
    queryset = Files.objects.all()
    serializer_class = FileSerializers
    throttle_classes = [ConditionalThrottle]
    authentication_classes = [CustomBasicAuthentication]
    permission_classes = [IsOnlyOwner|IsOnlyAdmin]
    http_method_names = ['get']


    def list(self, request, *args, **kwargs):
        try:
            auth_header = self.request.headers.get('Authorization')
            no_use, auth_string = auth_header.split(' ')
            if no_use == 'Basic':
                decoded_auth_string = base64.b64decode(smart_str(auth_string)).decode('utf-8')
                username, password= decoded_auth_string.split(':')
                file_hash = request.query_params.get("file_hash")
                file_obj = Files.objects.get(file_hash=file_hash, username=username)
                ser_file_obj = FileSerializers(instance=file_obj)
                file_path = ser_file_obj.data["downloadable_link"]
                if os.path.exists(file_path):
                    response = FileResponse(open(file_path, 'rb'))
                    return response
                else:
                    return Response({"error": "file not found"}, status.HTTP_400_BAD_REQUEST)
            else:
                file_hash = request.query_params.get('file_hash')
                username = request.query_params.get('username')
                file_obj = Files.objects.get(file_hash=file_hash, username=username)
                ser_file_obj = FileSerializers(instance=file_obj)
                file_path = ser_file_obj.data["downloadable_link"]
                if os.path.exists(file_path):
                    response = FileResponse(open(file_path, 'rb'))
                    return response
                else:
                    return Response({"error": "file not found"}, status.HTTP_400_BAD_REQUEST)
        except:
            logging.error(traceback.format_exc())
            return Response({"error": "file not found"}, status.HTTP_400_BAD_REQUEST)

class LogServerView(ModelViewSet):
    queryset = LogServerConfig.objects.all()
    serializer_class = LogServerSerializer
    authentication_classes = [CustomBasicAuthentication]
    permission_classes = [IsOnlyAdmin]

class ScannersView(ModelViewSet):
    queryset = Scanners.objects.all()
    serializer_class = ScannerSerializer
    authentication_classes = [CustomBasicAuthentication]
    permission_classes = [IsOnlyAdmin]


    def list(self, request, *args, **kwargs):
        profile = {}
        scanner_information = Scanners.objects.first()
        ser_scanner_information = self.get_serializer(scanner_information)
        profile = ser_scanner_information.data
        uri, url = license_profile_endpoint()
        encoded_hash, expiry = generate_secure_link(uri)
        license_profile_url = url + f"&md5={encoded_hash}&expires={expiry}"
        request = requests.get(license_profile_url)
        if request.status_code == 200:
            response = json.loads(request.content)
            profile['license_id'] = response['license_id']
            profile['valid_license'] = response['valid_license']
            profile['username'] = response['username']
            profile['email'] = response['email']
            profile['license_expiration_date'] = response['license_expiration']
            profile['license_creation'] = response['license_creation']
        else:
            dict.fromkeys(profile, None)
        return Response(profile, status.HTTP_200_OK)


